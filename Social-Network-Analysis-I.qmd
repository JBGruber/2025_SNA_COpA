---
title: "Social Network Analysis 1"
title-slide-attributes:
    data-background-image: media/opinion_i.gif
    data-background-repeat: "repeat"
    data-background-size: "10%"
subtitle: "COST Action Training School in Computational Opinion Analysis -- COpA"
footer: "COpA -- 28th May 2025, Elbasan"
author: "Johannes B. Gruber | GESIS"
format: 
  revealjs:
    embed-resources: true
    theme: [default, custom.scss]
    width: 1600
    height: 900
    smaller: true
    scrollable: true
    incremental: false   
    logo: media/opinion_i.gif
execute: 
  eval: true
  cache: true
  freeze: auto
bibliography: references.bib
---

```{r setup}
#| include: false
library(igraph)
library(tidygraph)
library(tidyverse)
library(tinytable)
library(ggraph)
```

# Introduction
## What are *graphs*?

:::: {.columns}
::: {.column .fragment width="60%"}
### Mathematical Definition

A **graph** is a mathematical structure consisting of:

- **Vertices** (also called nodes or points)
- **Edges** (also called links or connections) that connect pairs of vertices

::: {.fragment}
### Think of it as...

- The mathematical "skeleton" or blueprint
- A formal way to represent relationships between things
- Abstract mathematical object with precise rules
:::
:::
::: {.column .fragment width="30%"}
### Real-world Analogy:

```{r subway, engine="tikz"}
\begin{tikzpicture}[
    % Define styles
    station/.style={circle, fill=white, draw=black, thick, minimum size=8pt},
    redline/.style={red, very thick},
    blueline/.style={blue, very thick},
    greenline/.style={green!60!black, very thick},
    label/.style={font=\small, black}
]

% Red Line connections (station to station)
\draw[redline] (0,2) -- (2,2);    % Oak to Maple
\draw[redline] (2,2) -- (4,2);    % Maple to Central
\draw[redline] (4,2) -- (6,2);    % Central to Pine
\draw[redline] (6,2) -- (8,2);    % Pine to Elm

% Blue Line connections (station to station)
\draw[blueline] (4,0) -- (4,1);   % Harbor to Market
\draw[blueline] (4,1) -- (4,2);   % Market to Central
\draw[blueline] (4,2) -- (4,3);   % Central to University
\draw[blueline] (4,3) -- (4,4);   % University to Heights
\draw[blueline] (4,4) -- (6,5);   % Heights to Ridge

% Green Line connections (station to station)
\draw[greenline] (1,1) -- (2,2);    % Valley to Park
\draw[greenline] (2,2) -- (3,2.5); 
\draw[greenline] (3,2.5) -- (4,3); % Park to Transit Hub
\draw[greenline] (4,3) -- (5,3.25);
\draw[greenline] (5,3.25) -- (7,4);   % Transit Hub to Summit

% Stations on Red Line
\node[station] (oak) at (0,2) {};
\node[station] (maple) at (2,2) {};
\node[station] (central) at (4,2) {};
\node[station] (pine) at (6,2) {};
\node[station] (elm) at (8,2) {};

% Stations on Blue Line
\node[station] (harbor) at (4,0) {};
\node[station] (market) at (4,1) {};
\node[station] (central) at (4,2) {};
\node[station] (transit) at (4,3) {};
\node[station] (heights) at (4,4) {};
\node[station] (ridge) at (6,5) {};

% Stations on Green Line
\node[station] (valley) at (1,1) {};
\node[station] (park) at (3,2.5) {};
\node[station] (university) at (5,3.25) {};
\node[station] (summit) at (7,4) {};

% Station Labels
\node[label, below left] at (oak) {Oak St};
\node[label, below] at (maple) {Maple Ave};
\node[label, below right] at (central) {Central};
\node[label, below] at (pine) {Pine Plaza};
\node[label, below right] at (elm) {Elm End};

\node[label, below] at (harbor) {Harbor};
\node[label, right] at (market) {Market};
\node[label, below] at (university) {University};
\node[label, left] at (heights) {Heights};
\node[label, above right] at (ridge) {Ridge View};

\node[label, below left] at (valley) {Valley};
\node[label, above left] at (park) {Park};
\node[label, above left] at (transit) {Transit Hub};
\node[label, above right] at (summit) {Summit};

% Legend
\node[label] at (9,4.5) {\textbf{Metro Lines:}};
\draw[redline] (9,4) -- (9.5,4) node[label, right] {Red Line};
\draw[blueline] (9,3.5) -- (9.5,3.5) node[label, right] {Blue Line};
\draw[greenline] (9,3) -- (9.5,3) node[label, right] {Green Line};


\end{tikzpicture}
```

**subway map** -- shows which stations connect to which, no info about stations themselves
:::
::::


## What are *networks*?

```{r}
nodes <- tribble(
  ~name, ~course, ~course_id, ~day, ~WG1, ~WG2, ~WG3, ~WG4,
  "Johannes",  "Social Network Analysis", 1L, 1L, FALSE, TRUE, FALSE, TRUE,
  "Aleksandra",  "Algorithmic Bias", 2L, 1L, FALSE, TRUE, FALSE, TRUE,
  "Jamal",  "Multi-lingual Analysis", 3L, 2L, FALSE, TRUE, TRUE, FALSE,
  "Felicia",  "Multi-modal Analysis", 4L, 2L, FALSE, TRUE, FALSE, FALSE,
)

edges <- tribble(
  ~from, ~to, ~same_day, ~same_wg,
  1, 2, TRUE, 2,
  1, 3, FALSE, 1,
  1, 4, FALSE, 1,
  2, 3, FALSE, 1,
  2, 4, FALSE, 1,
  3, 4, TRUE, 1,
)
```


:::: {.columns}
::: {.column width="60%"}
### Nodes (aka. vertices)
```{r}
nodes |> 
  mutate(across(where(is_logical), \(x) c("&#x274C;", "&#x2705;")[x + 1])) |> 
  tt(theme = "striped") |> 
  format_tt(markdown = TRUE)
```
:::

::: {.column width="10%"}
:::

::: {.column .fragment width="30%"}
### Edges
```{r}
edges |> 
  mutate(across(where(is_logical), \(x) c("&#x274C;", "&#x2705;")[x + 1])) |> 
  tt(theme = "striped")
```
:::
::::

::: {.fragment}
A [network]{.kn-yellow} is a [graph]{.kn-yellow}  where we [add attributes]{.kn-yellow} to give the graph [real-world meaning]{.kn-yellow}.
:::

## Sidenote: Adjacency Matrix

```{r}
instructors_graph <- tbl_graph(nodes = nodes, edges = edges, directed = FALSE)
adjacency <- igraph::as_adjacency_matrix(instructors_graph)
tt(as_tibble(as.matrix(adjacency), rownames = " "), theme = "striped")
```


## How do we *visualize* a *networks*?

A network visualization consists of: the [nodes]{.kn-yellow}

```{r}
#| fig-width: 10
#| fig-height: 5
instructors_graph |> 
  mutate(name_short = substr(name, 1, 2)) |> 
  ggraph(layout = "linear") +
  # geom_edge_link(aes(edge_width = same_wg), alpha = .75, show.legend = FALSE) +
  # scale_edge_width(range = c(1, 2)) +
  geom_node_point(fill = "firebrick", colour = "darkgrey", size = 10, shape = 21) +
  geom_node_text(aes(label = name_short), colour = "white") +
  theme_graph()
```


## How do we *visualize* a *networks*?

A network visualization consists of: the nodes, the [edges]{.kn-yellow}

```{r}
#| fig-width: 10
#| fig-height: 5
instructors_graph |> 
  mutate(name_short = substr(name, 1, 2)) |> 
  ggraph(layout = "linear") +
  geom_edge_link(aes(edge_width = same_wg), alpha = .75, show.legend = FALSE) +
  scale_edge_width(range = c(1, 2)) +
  geom_node_point(fill = "firebrick", colour = "darkgrey", size = 10, shape = 21) +
  geom_node_text(aes(label = name_short), colour = "white") +
  theme_graph()
```

## How do we *visualize* a *networks*?

A network visualization consists of: the nodes, the edges and the [layout]{.kn-yellow}

```{r}
#| fig-width: 10
#| fig-height: 5
instructors_graph |> 
  mutate(name_short = substr(name, 1, 2)) |> 
  ggraph(layout = "kk") +
  geom_edge_link(aes(edge_width = same_wg), alpha = .75, show.legend = FALSE) +
  scale_edge_width(range = c(1, 2)) +
  geom_node_point(fill = "firebrick", colour = "darkgrey", size = 10, shape = 21) +
  geom_node_text(aes(label = name_short), colour = "white") +
  theme_graph()
```

[**Undirected** network visualization of instructors using the **Kamada-Kawai** layout algorithm. **Nodes represent instructors** (labeled with their first two initials), edges connect instructors who are members of the **same working group**, with edge thickness proportional to the extent of their shared group membership (**thicker lines indicate stronger connections**).]{.nord-footer .fragment}

## What are *networks*?

```{r}
#| fig-width: 10
#| fig-height: 5
instructors_graph |> 
  activate("edges") |> 
  filter(same_day) |> 
  activate("nodes") |> 
  mutate(name_short = substr(name, 1, 2)) |> 
  ggraph(layout = "kk") +
  geom_edge_link( alpha = .75, show.legend = FALSE) +
  scale_edge_width(range = c(1, 2)) +
  geom_node_point(fill = "firebrick", colour = "darkgrey", size = 10, shape = 21) +
  geom_node_text(aes(label = name_short), colour = "white") +
  theme_graph()
```

[Undirected network visualization of instructors using the Kamada-Kawai layout algorithm. Nodes represent instructors (labeled with their first two initials), **edges connect instructors teaching on the same day**.]{.nord-footer .fragment}


## What can be Nodes and Edges

:::: {.columns}
::: {.column width="50%"}
### Nodes (Vertices) - The "Things"

- **People**: actors, politicians, students, customers, patients
- **Organizations**: companies, schools, hospitals, governments, NGOs
- **Places**: cities, countries, buildings, rooms, coordinates
- **Concepts**: ideas, topics, themes, categories, keywords
- **Content**: texts, documents, books, articles, posts, tweets
- **Digital entities**: websites, social media profiles, email addresses
- **Biological entities**: genes, proteins, species, cells
- **Objects**: products, artworks, patents, research papers
:::
::: {.column .fragment width="50%"}
### Edges (Links) - The "Relationships"

- **Social connections**: friendship, family ties, romantic relationships, mentorship
- **Professional ties**: collaboration, employment, supervision, partnership
- **Communication**: messages, emails, phone calls, citations, mentions
- **Affiliation**: membership, attendance, participation, ownership
- **Geographic**: proximity, travel routes, migration patterns
- **Temporal**: sequence, causation, co-occurrence in time
- **Semantic**: similarity, opposition, hierarchy, categorization
- **Transactional**: purchases, payments, exchanges, transfers
- **Influence**: leadership, endorsement, recommendation, following
- affiliation
:::
::::


## Unimodal vs Multimodal Nodes

:::: {.columns}
::: {.column width="50%"}
### Unimodal Networks

**One type of node** - all nodes represent the same kind of entity

- **Example**: Social network where all nodes are people
- **Connections**: Direct relationships between similar entities
- **Analysis**: Straightforward - compare like with like
:::
::: {.column .fragment width="50%"}
### Multimodal Networks

**Multiple types of nodes** - nodes represent different kinds of entities

- **Example**: Network with both people and organizations
- **Connections**: Relationships between different types of entities
- **Analysis**: More complex - different node types may have different properties

:::
::::

## Example: Discourse Network Analysis

```{r, engine = 'tikz'}
\tikzset{
 actor/.style ={circle, draw=red!50!yellow, fill=red!20!yellow, thick, inner sep=1pt},
 category/.style ={circle, draw=blue!70, fill=blue!40, thick, inner sep=1pt},
 gray/.style ={line width=0.5mm, color=gray, inner sep=0pt},
 black/.style ={line width=0.5mm, dashed},
 annotation/.style = {fill=gray!50, rounded corners=3}
}

\begin{tikzpicture}[scale=.8]

 \node [actor] (a1) at (0,4) {$a_1$};
 \node [actor] (a2) at (1,3) {$a_2$};
 \node [actor] (a3) at (0,2) {$a_3$};
 \node [actor] (a4) at (1,1) {$a_4$};
 \node [actor] (a5) at (0,0) {$a_5$};

 \node at (7,5.5) {};

 \node [annotation] at (0,5) {actors};

\end{tikzpicture}
```

## Example: Discourse Network Analysis

```{r, engine = 'tikz'}
\tikzset{
 actor/.style ={circle, draw=red!50!yellow, fill=red!20!yellow, thick, inner sep=1pt},
 category/.style ={circle, draw=blue!70, fill=blue!40, thick, inner sep=1pt},
 gray/.style ={line width=0.5mm, color=gray!40, inner sep=0pt},
 black/.style ={line width=0.5mm, dashed},
 annotation/.style = {fill=gray!50, rounded corners=3}
}

\begin{tikzpicture}[scale=.8]

 \node [actor] (a1) at (0,4) {$a_1$};
 \node [actor] (a2) at (1,3) {$a_2$};
 \node [actor] (a3) at (0,2) {$a_3$};
 \node [actor] (a4) at (1,1) {$a_4$};
 \node [actor] (a5) at (0,0) {$a_5$};

 \node [category] (c1) at (5,4.5) {};
 \node [category] (c11) at (5,4) {};
 \node [category] (c2) at (7,3) {};
 \node [category] (c3) at (6,2.4) {};
 \node [category] (c31) at (6,2.2) {};
 \node [category] (c32) at (6,2) {};
 \node [category] (c33) at (6,1.8) {};
 \node [category] (c4) at (5,0) {};
 \node [category] (c5) at (7,1) {};

 \draw [gray] (a1) to (c1);
 \draw [gray] (a2) to (c11);
 \draw [gray] (a2) to (c2);
 \draw [gray] (a2) to (c3);
 \draw [gray] (a3) to (c31);
 \draw [gray] (a3) to (c5);
 \draw [gray] (a4) to (c32);
 \draw [gray] (a5) to (c33);
 \draw [gray] (a5) to (c4);

 \node at (7,5.5) {};

 \node [annotation] at (0,5) {actors};
 \node [annotation] at (6,5) {statements};

\end{tikzpicture}
```

## Example: Discourse Network Analysis

```{r, engine = 'tikz'}
\tikzset{
 actor/.style ={circle, draw=red!50!yellow, fill=red!20!yellow, thick, inner sep=1pt},
 category/.style ={circle, draw=blue!70, fill=blue!40, thick, inner sep=1pt},
 gray/.style ={line width=0.5mm, color=gray!40, inner sep=0pt},
 black/.style ={line width=0.5mm, dashed},
 annotation/.style = {fill=gray!50, rounded corners=3}
}

\begin{tikzpicture}[scale=.8]

 \node [actor] (a1) at (0,4) {$a_1$};
 \node [actor] (a2) at (1,3) {$a_2$};
 \node [actor] (a3) at (0,2) {$a_3$};
 \node [actor] (a4) at (1,1) {$a_4$};
 \node [actor] (a5) at (0,0) {$a_5$};

 \node [category] (c1) at (5,4) {$c_1$};
 \node [category] (c2) at (7,3) {$c_2$};
 \node [category] (c3) at (6,2) {$c_3$};
 \node [category] (c4) at (5,0) {$c_4$};
 \node [category] (c5) at (7,1) {$c_5$};

 \draw [gray] (a1) to (c1);
 \draw [gray] (a2) to (c1);
 \draw [gray] (a2) to (c2);
 \draw [gray] (a2) to (c3);
 \draw [gray] (a3) to (c3);
 \draw [gray] (a3) to (c5);
 \draw [gray] (a4) to (c3);
 \draw [gray] (a5) to (c3);
 \draw [gray] (a5) to (c4);

 \node at (7,5.5) {};

 \node [annotation] at (0,5) {actors};
 \node [annotation] at (6,5) {concepts};

\end{tikzpicture}
```

## Example: Discourse Network Analysis

```{r, engine = 'tikz'}
\tikzset{
 actor/.style ={circle, draw=red!50!yellow, fill=red!20!yellow, thick, inner sep=1pt},
 category/.style ={circle, draw=blue!70, fill=blue!40, thick, inner sep=1pt},
 gray/.style ={line width=0.5mm, color=gray!40, inner sep=0pt},
 black/.style ={line width=0.5mm, dashed},
 annotation/.style = {fill=gray!50, rounded corners=3}
}

\begin{tikzpicture}[scale=.8]

 \node [actor] (a1) at (0,4) {$a_1$};
 \node [actor] (a2) at (1,3) {$a_2$};
 \node [actor] (a3) at (0,2) {$a_3$};
 \node [actor] (a4) at (1,1) {$a_4$};
 \node [actor] (a5) at (0,0) {$a_5$};

 \node [category] (c1) at (5,4) {$c_1$};
 \node [category] (c2) at (7,3) {$c_2$};
 \node [category] (c3) at (6,2) {$c_3$};
 \node [category] (c4) at (5,0) {$c_4$};
 \node [category] (c5) at (7,1) {$c_5$};

 \draw [gray] (a1) to (c1);
 \draw [gray] (a2) to (c1);
 \draw [gray] (a2) to (c2);
 \draw [gray] (a2) to (c3);
 \draw [gray] (a3) to (c3);
 \draw [gray] (a3) to (c5);
 \draw [gray] (a4) to (c3);
 \draw [gray] (a5) to (c3);
 \draw [gray] (a5) to (c4);

 \draw [black] (a1) to (a2);
 \draw [black] (a2) to (a3);
 \draw [black] (a2) to (a5);
 \draw [black] (a3) to (a4);
 \draw [black] (a3) to (a5);
 \draw [black] (a2) to (a4);
 \draw [black] (a4) to (a5);


 \node at (7,5.5) {};

 \node [annotation] at (0,5) {actors};
 \node [annotation] at (6,5) {concepts};

\end{tikzpicture}
```


## Example: Discourse Network Analysis

```{r, engine = 'tikz'}
\tikzset{
 actor/.style ={circle,draw=red!50!yellow,fill=red!20!yellow,thick,inner sep=1pt},
 category/.style ={circle,draw=blue!70,fill=blue!40,thick,inner sep=1pt},
 gray/.style ={line width=0.5mm, dashed,color=gray,inner sep=0pt},
 black/.style ={line width=0.5mm},
 annotation/.style = {fill=gray!50, rounded corners=3}
}
\begin{tikzpicture}
   \node [actor] (a1) at (0,1) {$a_1$};
   \node [actor] (a2) at (0,0) {$a_2$};
   \node [category] (c1) at (3,0.5) {$c_1$};
   \draw [gray] (a1) to node [above=1mm,circle,solid,line width=0.2mm] {\textbf{+}} (c1);
   \draw [gray] (a2) to node [below=1mm,circle,solid,line width=0.2mm] {\textbf{+}} (c1);
   \draw [black] (a1) to (a2);
   \node [annotation,right=-3mm] at (0,2.3) {congruence networks};

   \node [actor] (a1) at (5.5,1) {$a_1$};
   \node [actor] (a2) at (5.5,0) {$a_2$};
   \node [category] (c1) at (8.5,0.5) {$c_1$};
   \draw [gray] (a1) to node [above=1mm,circle,solid,line width=0.2mm] {\textbf{+}} (c1);
   \draw [gray] (a2) to node [below=1mm,circle,solid,line width=0.2mm] {\textbf{--}} (c1);
   \draw [black] (a1) to (a2);
   \node [annotation,right=-3mm] at (5.5,2.3) {conflict networks};

   \node [actor] (a1) at (0,-1.5) {$a_1$};
   \node [actor] (a2) at (0,-2.5) {$a_2$};
   \node [category] (c1) at (3,-2) {$c_1$};
   \draw [gray] (a1) to node [above=1mm,circle,solid,line width=0.2mm] {\textbf{--}} (c1);
   \draw [gray] (a2) to node [below=1mm,circle,solid,line width=0.2mm] {\textbf{--}} (c1);
   \draw [black] (a1) to (a2);

   \node [actor] (a1) at (5.5,-1.5) {$a_1$};
   \node [actor] (a2) at (5.5,-2.5) {$a_2$};
   \node [category] (c1) at (8.5,-2) {$c_1$};
   \draw [gray] (a1) to node [above=1mm,circle,solid,line width=0.2mm] {\textbf{--}} (c1);
   \draw [gray] (a2) to node [below=1mm,circle,solid,line width=0.2mm] {\textbf{+}} (c1);
   \draw [black] (a1) to (a2);
\end{tikzpicture}
```

[Illustration: congruence and conflict networks with a binary qualifier variable. Source: @rDNA.2019.]{.nord-footer}


## Undirected vs. Directed Edges

:::: {.columns}
::: {.column width="50%"}
```{r}
citation_edgelist <- tibble(
  citing_paper = c(
    "Smith2023", "Smith2023", "Smith2023",
    "Jones2022", "Jones2022", 
    "Brown2024", "Brown2024", "Brown2024", "Brown2024",
    "Davis2021", "Davis2021",
    "Wilson2023", "Wilson2023", "Wilson2023",
    "Garcia2024", "Garcia2024",
    "Lee2022"
  ),
  cited_paper = c(
    "Johnson2020", "Williams2019", "Davis2021",
    "Johnson2020", "Miller2018",
    "Smith2023", "Jones2022", "Johnson2020", "Williams2019",
    "Miller2018", "Anderson2017",
    "Davis2021", "Johnson2020", "Miller2018",
    "Brown2024", "Wilson2023",
    "Anderson2017"
  )
)
citation_edgelist |> 
  tt(theme = "striped") |> 
  format_tt(markdown = TRUE)
```
:::
::: {.column .fragment width="50%"}
```{r}
tbl_graph(edges = citation_edgelist, directed = TRUE) |> 
  ggraph(layout = 'stress') +
  geom_edge_link(arrow = arrow(length = unit(4, 'mm')), 
                  start_cap = circle(3, 'mm'),
                  end_cap = circle(3, 'mm')) +
  geom_node_point(fill = "firebrick", colour = "darkgrey", size = 10, shape = 21) +
  geom_label(aes(x = x, y = y, label = name), nudge_y = 0.2, label.size = NA) +
  theme_graph()
```
:::
::::

## Weighted vs. Unweighted Edges

:::: {.columns}
::: {.column width="50%"}
```{r}
set.seed(1)
citation_edgelist <- tibble(
  citing_paper = c(
    "Smith2023", "Smith2023", "Smith2023",
    "Jones2022", "Jones2022", 
    "Brown2024", "Brown2024", "Brown2024", "Brown2024",
    "Davis2021", "Davis2021",
    "Wilson2023", "Wilson2023", "Wilson2023",
    "Garcia2024", "Garcia2024",
    "Lee2022"
  ),
  cited_paper = c(
    "Johnson2020", "Williams2019", "Davis2021",
    "Johnson2020", "Miller2018",
    "Smith2023", "Jones2022", "Johnson2020", "Williams2019",
    "Miller2018", "Anderson2017",
    "Davis2021", "Johnson2020", "Miller2018",
    "Brown2024", "Wilson2023",
    "Anderson2017"
  )
) |> 
  mutate(times = sample(1:5, n(), replace = TRUE))
citation_edgelist |> 
  tt(theme = "striped") |> 
  format_tt(markdown = TRUE)
```
:::
::: {.column .fragment width="50%"}
```{r}
tbl_graph(edges = citation_edgelist, directed = TRUE) |> 
  ggraph(layout = 'stress') +
  geom_edge_link(aes(edge_width = times, alpha = times),
                 arrow = arrow(length = unit(4, 'mm')), 
                 start_cap = circle(5, 'mm'),
                 end_cap = circle(5, 'mm'), 
                 show.legend = FALSE) +
  scale_edge_width(range = c(1, 2)) +
  geom_node_point(fill = "firebrick", colour = "darkgrey", size = 10, shape = 21) +
  geom_label(aes(x = x, y = y, label = name), nudge_y = 0.2, label.size = NA) +
  theme_graph()
```
:::
::::

## What is a path

:::: {.columns}
::: {.column .incremental width="50%"}
- A path is a route that runs along the links of the network. A path’s length = the number of links the path contains
- The shortest path between nodes i and j is the path with the fewest number of links
- Network diameter = the maximum shortest path in the network
- Average path length = average distance between all pairs of nodes in the network
:::

::: {.column width="50%"}
![](media/closeness.gif)
:::
::::

## What is Centrality?

<!-- taken from https://github.com/schochastics/MH_netAnaR -->

:::: {.columns}
::: {.column .incremental width="50%"}
- Measures how "central" a node is in a network
- "Being central" is a very ambiguous, so many measures exist
- Measures assess centrality with very different structural properties of the network
:::

::: {.column width="50%"}
```{r dbces11_basic_plot,echo=FALSE}
dbces11 <- as_tbl_graph(netrankr::dbces11)
dbces11 |> 
  ggraph(layout = "stress") + 
  geom_edge_link0() +
  geom_node_point(shape = 21, size = 10, fill = "grey66") +
  geom_node_text(aes(label = name)) +
  theme_void() +
  coord_equal(clip = "off")
```
:::
::::

## What is Centrality?

:::: {.columns}
::: {.column .incremental width="50%"}
- **degree** centrality simply counts the number of neighbors a node has.

:::

::: {.column width="50%"}
```{r}
dbces11 |> 
  activate(nodes) |> 
  mutate(degree = centrality_degree(),
         highest = degree == max(degree)) |> 
  activate(edges) |> 
  mutate(highest = .N()$highest[from] | .N()$highest[to]) |> 
  ggraph(layout = "stress") + 
  geom_edge_link(aes(col = highest), show.legend = FALSE) +
  geom_node_point(aes(fill = highest), shape = 21, size = 10, show.legend = FALSE) +
  geom_node_text(aes(label = name)) +
  theme_void() +
  scale_fill_manual(values = c("grey66", "firebrick3")) +
  scale_edge_color_manual(values = c("grey66", "firebrick3"))
  coord_equal(clip = "off")
```
:::
::::

## What is Centrality?

:::: {.columns}
::: {.column .incremental width="50%"}
- **degree** centrality simply counts the number of neighbors a node has.
- **closeness** computes the shortest path distances among nodes. The most central node has the minimum distance to all other nodes
:::

::: {.column width="50%"}
```{r degree_dbces11_plot,echo=FALSE}
dbces11 |> 
  activate(nodes) |> 
  mutate(degree = centrality_closeness(),
         highest = degree == max(degree)) |> 
  activate(edges) |> 
  mutate(highest = .N()$highest[from] | .N()$highest[to]) |> 
  ggraph(layout = "stress") + 
  geom_edge_link(aes(col = highest), show.legend = FALSE) +
  geom_node_point(aes(fill = highest), shape = 21, size = 10, show.legend = FALSE) +
  geom_node_text(aes(label = name)) +
  theme_void() +
  scale_fill_manual(values = c("grey66", "firebrick3")) +
  scale_edge_color_manual(values = c("grey66", "firebrick3"))
  coord_equal(clip = "off")
```
:::
::::

## What is Centrality?

:::: {.columns}
::: {.column .incremental width="50%"}
- **degree** centrality simply counts the number of neighbors a node has.
- **closeness** computes the shortest path distances among nodes. The most central node has the minimum distance to all other nodes
- **betweeness** is the number of shortest paths that pass through a node (divided by the total number of shortest paths) 
:::

::: {.column width="50%"}
```{r}
dbces11 |> 
  activate(nodes) |> 
  mutate(degree = centrality_betweenness(),
         highest = degree == max(degree)) |> 
  activate(edges) |> 
  mutate(highest = .N()$highest[from] | .N()$highest[to]) |> 
  ggraph(layout = "stress") + 
  geom_edge_link(aes(col = highest), show.legend = FALSE) +
  geom_node_point(aes(fill = highest), shape = 21, size = 10, show.legend = FALSE) +
  geom_node_text(aes(label = name)) +
  theme_void() +
  scale_fill_manual(values = c("grey66", "firebrick3")) +
  scale_edge_color_manual(values = c("grey66", "firebrick3"))
  coord_equal(clip = "off")
```
:::
::::

## What is Centrality?

:::: {.columns}
::: {.column .incremental width="50%"}
- **degree** centrality simply counts the number of neighbors a node has.
- **closeness** computes the shortest path distances among nodes. The most central node has the minimum distance to all other nodes
- **betweeness** is the number of shortest paths that pass through a node (divided by the total number of shortest paths) 
- **eigenvector centrality** extends the idea of degree by assuming that a node is central if it is connected to other central nodes.
:::

::: {.column width="50%"}
```{r}
dbces11 |> 
  activate(nodes) |> 
  mutate(degree = centrality_eigen(),
         highest = degree == max(degree)) |> 
  activate(edges) |> 
  mutate(highest = .N()$highest[from] | .N()$highest[to]) |> 
  ggraph(layout = "stress") + 
  geom_edge_link(aes(col = highest), show.legend = FALSE) +
  geom_node_point(aes(fill = highest), shape = 21, size = 10, show.legend = FALSE) +
  geom_node_text(aes(label = name)) +
  theme_void() +
  scale_fill_manual(values = c("grey66", "firebrick3")) +
  scale_edge_color_manual(values = c("grey66", "firebrick3"))
  coord_equal(clip = "off")
```
:::
::::

## What is Centrality?

:::: {.columns}
::: {.column .incremental width="50%"}
- **degree** centrality simply counts the number of neighbors a node has.
- **closeness** computes the shortest path distances among nodes. The most central node has the minimum distance to all other nodes
- **betweeness** is the number of shortest paths that pass through a node (divided by the total number of shortest paths) 
- **eigenvector centrality** extends the idea of degree by assuming that a node is central if it is connected to other central nodes.
- **subgraph centrality** is a bit more abstract but what it does is summing up all closed walks weighting them by the 
inverse factorial of its length.
:::

::: {.column width="50%"}
```{r}
dbces11 |> 
  activate(nodes) |> 
  mutate(degree = centrality_subgraph(),
         highest = degree == max(degree)) |> 
  activate(edges) |> 
  mutate(highest = .N()$highest[from] | .N()$highest[to]) |> 
  ggraph(layout = "stress") + 
  geom_edge_link(aes(col = highest), show.legend = FALSE) +
  geom_node_point(aes(fill = highest), shape = 21, size = 10, show.legend = FALSE) +
  geom_node_text(aes(label = name)) +
  theme_void() +
  scale_fill_manual(values = c("grey66", "firebrick3")) +
  scale_edge_color_manual(values = c("grey66", "firebrick3"))
  coord_equal(clip = "off")
```
:::
::::

## What is Homophily?

:::: {.columns}
::: {.column width="60%"}
### The Basic Principle

**Homophily** is the tendency for similar people to connect to each other in social networks.

::: {.fragment}
### "Birds of a feather flock together"

- People tend to form connections with others who are similar to them
- Similarity can be based on many attributes:
  - Demographics (age, gender, race, education)
  - Attitudes and beliefs
  - Behaviors and interests
  - Geographic location
  - Social status
  - Opinions
:::

::: {.fragment}
### Two Types of Homophily

- **Selection homophily**: People choose to connect with similar others
- **Influence homophily**: Connected people become more similar over time
:::
:::

::: {.column .fragment width="40%"}
![](media/divided_they_blog.png)
:::
::::

## What are Structural Holes?

:::: {.columns}
::: {.column width="60%"}

A **structural hole** is a gap between two parts of a network that are not directly connected.

- Social networks consist of groups
- Often groups are homogeneous
- There are structural holes between groups [3]
- Ties that bridge structural holes
  - are sources of novelty
  - have information advantages
  - wield power
:::

::: {.column  width="40%"}
```{r}
cluster1_nodes <- 1:10
cluster1_edges <- expand.grid(from = cluster1_nodes, to = cluster1_nodes) %>%
  filter(from < to) %>%
  sample_frac(0.7)

cluster2_nodes <- 11:18
cluster2_edges <- expand.grid(from = 11:18, to = 11:18) %>%
  filter(from < to) %>%
  sample_frac(0.8)

bridge_edges <- tibble(
  from = c(5, 7),
  to = c(12, 15) 
)

all_edges <- rbind(cluster1_edges, cluster2_edges, bridge_edges)

# Create node attributes
nodes <- data.frame(
  id = 1:18,
  cluster = c(rep("Cluster 1", 10), rep("Cluster 2", 8))
)

tbl_graph(nodes = nodes, edges = all_edges, directed = FALSE) |> 
  ggraph(layout = "stress") +
  # ggforce::geom_mark_hull() +
  geom_edge_link(color = "gray60", alpha = 0.6, width = 0.8) +
  geom_node_point(aes(color = cluster), size = 6, show.legend = FALSE) +
  scale_color_manual(values = c("Cluster 1" = "#20B2AA", "Cluster 2" = "#DAA520")) +
  geom_abline(intercept = 1, slope = 5, linetype = "dashed") +
  # geom_node_text(aes(label = x)) +
  theme_void()
```

:::
::::

## What are Structural Holes?

:::: {.columns}
::: {.column width="50%"}
### Burt's Theory

**Ronald Burt** developed structural hole theory, arguing that:

- **Social capital** comes from bridging structural holes
- **Competition** is more about network position than individual attributes
- **Entrepreneurial opportunities** arise from spanning disconnected groups

### Real-World Examples

- **Venture capitalists**: Connect entrepreneurs with investors
- **Consultants**: Bridge different industries or departments
- **Translators**: Connect different language communities
- **Interdisciplinary researchers**: Bridge different academic fields
- **Cultural brokers**: Connect different ethnic or cultural groups
:::

::: {.column .fragment width="50%"}
### Measuring Structural Holes

**Constraint**: Measures how much a node's network constrains its actions
- Lower constraint = more structural holes
- Higher constraint = more redundant connections

**Efficiency**: Ratio of non-redundant contacts
- Higher efficiency = better positioned to exploit structural holes

```{r}
dbces11 |> 
  activate(nodes) |> 
  mutate(constraint = node_constraint(),
         highest = constraint == max(constraint)) |> 
  activate(edges) |> 
  mutate(highest = .N()$highest[from] | .N()$highest[to]) |> 
  ggraph(layout = "stress") + 
  geom_edge_link(aes(col = highest), show.legend = FALSE) +
  geom_node_point(aes(fill = highest), shape = 21, size = 10, show.legend = FALSE) +
  geom_node_text(aes(label = name)) +
  theme_void() +
  scale_fill_manual(values = c("grey66", "firebrick3")) +
  scale_edge_color_manual(values = c("grey66", "firebrick3"))
  coord_equal(clip = "off")
```


### The Trade-off: Brokerage vs. Closure

```{r brokerage_closure, echo=FALSE}

# Brokerage network
brok_nodes <- tibble(id = 1:7, 
                    name = c("A", "B", "C", "Broker", "D", "E", "F"),
                    type = c(rep("Group 1", 3), "Bridge", rep("Group 2", 3)))

brok_edges <- tibble(from = c(1, 2, 3, 4, 5, 6, 7, 4, 4, 4),
                    to = c(2, 3, 1, 1, 6, 7, 5, 5, 6, 7))

brok_graph <- tbl_graph(nodes = brok_nodes, edges = brok_edges)

p1 <- brok_graph |> 
  ggraph(layout = "manual", x = c(-1, -1, -1, 0, 1, 1, 1), 
                           y = c(1, 0, -1, 0, 1, 0, -1)) +
  geom_edge_link(alpha = 0.8) +
  geom_node_point(aes(color = type), size = 8) +
  geom_node_text(aes(label = name), color = "white", size = 3) +
  scale_color_manual(values = c("Group 1" = "firebrick", "Bridge" = "gold", "Group 2" = "steelblue")) +
  theme_graph() +
  theme(legend.position = "none") +
  labs(title = "Brokerage: Access to diverse information")

# Closure network  
closure_nodes <- tibble(id = 1:6, name = c("A", "B", "C", "D", "E", "F"))
closure_edges <- tibble(from = c(1, 1, 1, 2, 2, 3, 3, 4, 5),
                       to = c(2, 3, 4, 3, 4, 4, 5, 5, 6))

closure_graph <- tbl_graph(nodes = closure_nodes, edges = closure_edges)

p2 <- closure_graph |> 
  ggraph(layout = "circle") +
  geom_edge_link(alpha = 0.8) +
  geom_node_point(color = "forestgreen", size = 8) +
  geom_node_text(aes(label = name), color = "white", size = 3) +
  theme_graph() +
  labs(title = "Closure: Trust and coordination")

# Note: In actual R Markdown, you'd use patchwork or similar to combine plots
```

**Left**: Brokerage provides information diversity  
**Right**: Closure provides trust and social cohesion
:::
::::

## What are Communities?

:::: {.columns}
::: {.column width="60%"}
### Definition

A **community** (or cluster) in a network is a group of nodes that are more densely connected to each other than to the rest of the network.

::: {.fragment}
### Key Characteristics

- **High internal density**: Many connections within the group
- **Low external density**: Fewer connections to other groups
- **Coherent structure**: Members share something meaningful in common

### Why Communities Matter

- **Information flow**: Ideas spread quickly within communities
- **Social identity**: Communities often reflect shared interests or demographics
- **Functional units**: Communities may represent meaningful social groups
- **Network resilience**: Understanding community structure helps predict how networks respond to changes
:::
:::

::: {.column .fragment width="40%"}
### Visual Example

```{r communities_visual, echo=FALSE}
# Create network with clear community structure
set.seed(123)
n_communities <- 3
n_per_community <- 6
total_nodes <- n_communities * n_per_community

community_nodes <- tibble(
  id = 1:total_nodes,
  community = rep(1:n_communities, each = n_per_community),
  name = paste0(rep(c("A", "B", "C"), each = n_per_community), 
                rep(1:n_per_community, n_communities))
)

# Generate edges with high within-community probability
community_edges <- tibble()
for(i in 1:(total_nodes-1)) {
  for(j in (i+1):total_nodes) {
    # Higher probability within communities
    if(community_nodes$community[i] == community_nodes$community[j]) {
      prob <- 0.4  # High internal connectivity
    } else {
      prob <- 0.05  # Low external connectivity
    }
    
    if(runif(1) < prob) {
      community_edges <- bind_rows(community_edges, 
                                  tibble(from = i, to = j))
    }
  }
}

community_graph <- tbl_graph(nodes = community_nodes, edges = community_edges)

community_graph |> 
  ggraph(layout = "fr") +
  geom_edge_link(alpha = 0.6, color = "grey60") +
  geom_node_point(aes(color = factor(community)), size = 6) +
  scale_color_manual(values = c("1" = "firebrick", "2" = "steelblue", "3" = "forestgreen")) +
  theme_graph() +
  theme(legend.position = "none")
```

[Network with three distinct communities - nodes are more connected within their color group]{.nord-footer}
:::
::::

## What is Community Detection?

:::: {.columns}
::: {.column width="50%"}
### The Challenge

**Community detection** is the computational task of automatically identifying communities in networks.

### Why is it Hard?

- **No universal definition**: What exactly constitutes a "community"?
- **Scale matters**: Communities can exist at different levels
- **Overlapping membership**: Nodes can belong to multiple communities
- **Dynamic networks**: Communities change over time

### Common Approaches

1. **Modularity optimization**: Find divisions that maximize internal vs. external connections
2. **Random walks**: Communities are areas where random walks get "trapped"
3. **Spectral methods**: Use eigenvalues of network matrices
4. **Label propagation**: Nodes adopt labels of their neighbors
:::

::: {.column .fragment width="50%"}
### Modularity

The most common quality measure for communities:

**Q = (fraction of edges within communities) - (expected fraction if random)**

- Q > 0.3 typically indicates good community structure
- Q = 0 means no better than random
- Q < 0 means worse than random

### Algorithm Example: Louvain Method

1. Start with each node in its own community
2. For each node, calculate modularity gain from joining each neighbor's community
3. Move node to community that gives highest gain
4. Repeat until no more improvements
5. Create new network where communities become nodes
6. Repeat entire process

### Validation Challenge

How do we know if detected communities are "real"?
- Compare with known ground truth (when available)
- Check stability across different runs
- Examine if communities match meaningful social categories
:::
::::

## What is Community Detection?

:::: {.columns}
::: {.column width="50%"}
### Real-World Applications

**Social Media Analysis**
- Friend groups on Facebook
- Topic communities on Twitter
- Professional networks on LinkedIn

**Biological Networks**
- Protein complexes in molecular networks
- Functional modules in brain networks
- Ecological communities in food webs

**Information Networks**
- Research fields in citation networks
- Topic clusters in document networks
- Product categories in recommendation systems

**Infrastructure Networks**
- Regional clusters in transportation networks
- Service areas in utility networks
:::

::: {.column .fragment width="50%"}
### Example: Academic Collaboration Network

```{r academic_communities, echo=FALSE}
# Simulate academic collaboration network
set.seed(456)
academic_nodes <- tibble(
  id = 1:15,
  researcher = paste0("R", 1:15),
  field = rep(c("Biology", "Chemistry", "Physics"), each = 5)
)

# Create field-based collaboration patterns
academic_edges <- tibble()
for(i in 1:14) {
  for(j in (i+1):15) {
    # Higher collaboration within fields
    if(academic_nodes$field[i] == academic_nodes$field[j]) {
      prob <- 0.6
    } else {
      prob <- 0.1
    }
    
    if(runif(1) < prob) {
      academic_edges <- bind_rows(academic_edges, 
                                 tibble(from = i, to = j, 
                                       collaborations = sample(1:5, 1)))
    }
  }
}

academic_graph <- tbl_graph(nodes = academic_nodes, edges = academic_edges)

academic_graph |> 
  ggraph(layout = "kk") +
  geom_edge_link(aes(width = collaborations), alpha = 0.7, color = "grey50") +
  geom_node_point(aes(color = field), size = 8) +
  geom_node_text(aes(label = researcher), color = "white", size = 2.5) +
  scale_color_manual(values = c("Biology" = "forestgreen", 
                               "Chemistry" = "firebrick", 
                               "Physics" = "steelblue")) +
  scale_edge_width(range = c(0.5, 2), guide = "none") +
  theme_graph() +
  labs(color = "Research Field")
```

[Researchers collaborate more within their academic fields, forming natural communities]{.nord-footer}

### Key Insight
Community detection reveals the **hidden structure** in networks that might not be obvious from looking at the raw connections alone.
:::
::::

## Communities vs. Other Network Concepts

:::: {.columns}
::: {.column width="50%"}
### How Communities Relate to Other Concepts

**Communities vs. Homophily**
- Homophily explains *why* communities form
- Communities are the *structural result* of homophilic processes
- Not all homophily leads to clear communities

**Communities vs. Structural Holes**
- Communities create structural holes *between* them
- Brokers span structural holes *between* communities
- Community boundaries are where structural holes appear

**Communities vs. Centrality**
- Central nodes can be central *within* communities or *between* communities
- Global centrality ≠ local (within-community) centrality
- Different centrality measures may identify different types of important nodes
:::

::: {.column .fragment width="50%"}
### Integration Example: Social Movement Networks

```{r movement_network, echo=FALSE}
# Create a social movement network showing all concepts
movement_nodes <- tibble(
  id = 1:12,
  name = c("Org1", "Org2", "Org3", "Bridge1", "Org4", "Org5", 
          "Org6", "Bridge2", "Org7", "Org8", "Org9", "Media"),
  type = c(rep("Environmental", 3), "Coalition", rep("Labor", 3), 
          "Coalition", rep("Civil Rights", 3), "Media"),
  centrality_type = c("Local", "Local", "Local", "Broker", "Local", "High", 
                     "Local", "Broker", "Local", "Local", "Local", "Global")
)

movement_edges <- tibble(
  from = c(1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 8, 9, 10, 11, 4, 8, 12, 12, 12),
  to = c(2, 3, 3, 4, 5, 6, 6, 7, 8, 9, 10, 10, 11, 10, 8, 4, 4, 8, 5)
)

movement_graph <- tbl_graph(nodes = movement_nodes, edges = movement_edges)

movement_graph |> 
  ggraph(layout = "kk") +
  geom_edge_link(alpha = 0.7, color = "grey50") +
  geom_node_point(aes(color = type, size = centrality_type == "High"), stroke = 1.5) +
  geom_node_text(aes(label = name), size = 2.5, color = "white") +
  scale_color_manual(values = c("Environmental" = "forestgreen", 
                               "Labor" = "firebrick", 
                               "Civil Rights" = "steelblue",
                               "Coalition" = "gold",
                               "Media" = "purple")) +
  scale_size_manual(values = c("TRUE" = 10, "FALSE" = 6), guide = "none") +
  theme_graph() +
  labs(color = "Organization Type")
```

- **Communities**: Environmental, Labor, Civil Rights groups
- **Structural Holes**: Between different movement sectors  
- **Brokers**: Coalition organizations spanning holes
- **Homophily**: Organizations connect with similar causes
- **Centrality**: Media outlet has high global reach
:::
::::

## What are communities/What is community detection

:::: {.columns}
::: {.column .incremental width="50%"}
- A cluster is loosely defined as a group of nodes which are internally densely and externally sparsely connected. 



In contrast, the network below does not really seem to have any well defined cluster structure.
:::

::: {.column width="50%"}
```{r clustered_graph,echo=FALSE}
n1 <- 5
n2 <- 20
set.seed(1234)
g <- sample_islands(n1, n2, 0.9, 5)
g <- simplify(g)
V(g)$grp <- rep(LETTERS[1:n1], each = n2)
ggraph(g, "stress") +
    geom_edge_link0(edge_width = 0.2, edge_color = "grey66") +
    geom_node_point(shape = 21, size = 5, aes(fill = grp), show.legend = FALSE) +
    theme_void()
```
:::
::::


```{r random_graph,echo=FALSE}
n1 <- 5
n2 <- 20

set.seed(1234)
g <- sample_islands(n1, n2, 0.25, 15)
g <- simplify(g)
V(g)$grp <- rep(LETTERS[1:n1], each = n2)
ggraph(g, "stress") +
    geom_edge_link0(edge_width = 0.2, edge_color = "grey66") +
    geom_node_point(shape = 21, size = 5, fill = "grey66", show.legend = FALSE) +
    theme_void()

```

## SNA Origins

:::: {.columns}
::: {.column width="45%"}
![](media/Simmel.png){width=41.5%} ![](media/jacob_moreno.jpg){width=41%}<br>[Left, Georg **Simmel** (1858-1918)<br>Right, Jacob **Moreno** (1889-1974)]{.nord-footer}

**Simmel**'s [[-@simmel2010conflict]]{.nord-light} "The Web of Group Affiliations" and **Moreno**'s [[-@moreno1934shall]]{.nord-light} *Who Shall Survive?* are generally considered to be the intellectual beginnings of SNA.
:::

::: {.column width="10%"}
:::

::: {.column width="45%"}
![](media/who_shall_survive.gif){width=100%}

*Who Shall Survive?* Helen Hall **Jennings** co-authored this classic without credit.
:::
::::


## SNA Uptake

:::: {.columns}
::: {.column width="45%"}
![The vertical line marks the publication of the first edition of the<br>*Sage Handbook of Social Network Analysis* [[@scott2011sage]]{.nord-light}.<br>Figure reproduced from [[@mclevey2023sage]]{.nord-light}.](media/social_networks_over_time.png){#fig-social_networks_over_time width=80%}
:::

::: {.column width="55%"}
![Latent topics in *Social Networks* over time. Reproduced from [@mclevey2023sage]{.nord-light}.](media/mclevey_scott_carrington_sna_topic_heatmap.png){#fig-mclevey_scott_carrington_sna_topic_heatmap}

SNA (and network science more generally) is [increasingly computational]{.kn-pink} [[see also @tindall2022big]]{.nord-light}.
:::
::::

## Small-World Networks


## Example: Divided They Blog

:::: {.columns}
::: {.column width="50%"}
![](media/divided_they_blog.png){#fig-divided_they_blog width="100%" .shadow-img}
:::

::: {.column width="50%"}
$\longleftarrow$<br>This famous figure from @adamic2005political shows a conservative-liberal divide in the American political blogosphere circa 2004.

- Nodes: political blogs
- Edges: links [("citations")]{.nord-light} to other blogs
- Color: liberal (blue), conservative (red)
- Size: indegree
- Layout: force directed

<br>

[Is the network structure<br>[[self-evident]{.kn-pink}]{.large-text}<br>here?]{.fragment}

:::
::::

## Divided They Blog: Alternative Plots

![](media/layouts.gif)

## How sure are you?

:::: {.columns}
::: {.column width="50%"}
![](media/divided_they_blog.png){width=100% .shadow-img}
:::

::: {.column width="50%"}
#### Common pitfalls and problems

[@peixoto2021modularity; @peixoto2023descriptive; @peixoto2021hairball]{.nord-footer}

- (Implicitly?) believing some approaches are more "model-free" than others
- (Implicitly?) believing that network structure will be self-evident and our intuitions will hold up when reasoning about high-dimensional network structure

Which often translates to:

- using heuristic approaches [(esp. modularity-maximization)]{.nord-light} to partition/reduce networks
- interpreting generic network visualizations [(esp. force-directed)]{.nord-light} without sufficient model criticism
:::
::::

## Nope

**Pareidolia** (/ˌpærɪˈdoʊliə, ˌpɛər-/;[1] also US: /ˌpɛəraɪ-/)[2] is the tendency for perception to impose a meaningful interpretation on a nebulous stimulus, usually visual, so that one detects an object, pattern, or meaning where there is none.

:::: {.columns}
::: {.column width="55%"}
![Figure reproduced from @peixoto2023descriptive](media/face_mars.png){width=86%}
:::

::: {.column width="5%"}
:::

::: {.column width="40%"}
![😂 [From https://x.com/GrandjeanMartin/status/1600154712380014594]{.nord-light}](media/jaws.png){width=80%}
:::
::::



## Community Detection...

[*...is like a good reduction*]{.kn-pink}

:::: {.columns}
::: {.column width="50%"}
![](media/reduction.jpg){width=70% .shadow-img}
:::

::: {.column width="50%"}
- an essential topic in network analysis
- high-level goal is to simplify network structure by partitioning and [reducing]{.kn-pink} complex observed networks
- there are different kinds of structure and subgroups
- there are different methods and models we can use
:::
::::

::: {.notes}
**The reduction analogy**

- Starting with Complexity: Just as you begin cooking with a variety of ingredients in a sauce, you start with a complex network that has many nodes and edges representing different interactions or relationships.
- Reducing to Essentials: In cooking, reducing a sauce involves simmering it to evaporate excess liquid, concentrating the flavors, and focusing on the essential ingredients. Similarly, blockmodeling simplifies the network by grouping similar nodes into blocks or communities, thereby reducing the complexity of the network and focusing on the essential structural patterns.
- Enhancing Understanding: The goal of reducing a sauce is to create a richer, more flavorful dish that enhances the overall meal. Likewise, the goal of blockmodeling is to create a clearer, more understandable representation of the network, making it easier to identify key patterns, relationships, and structures.
- Striking the Right Balance: Just as you must be careful not to reduce a sauce too much (which could lead to an overly intense or burnt flavor), in blockmodeling, it’s important to strike the right balance between simplification and preserving the network’s meaningful structure. Over-simplification could result in loss of important details.

- there are different kinds of structure and subgroups
  - assortative-connective, equivalent-positional
- there are different methods and models we can use
  - **heuristic-descriptive**
    - have been popular for some time
    - are deeply flawed and should be avoided
  - **generative-inferential**
    - not new [[e.g., @holland1983stochastic; @snijders1997estimation; @bearman2004chains]]{.nord-light}, better and more accessible than ever
    - strong opinion: must become be the standard
:::




# Part 2: Hands on


# Potential slides

##

### Heuristic Community Detection<br>via Modularity Maximization

<br><br>

:::: {.columns}
::: {.column width="55%"}

The Louvain [[@blondel2008fast]]{.nord-light} algorithm purports to detect communities in networks by maximizing a "modularity" score $Q$ [[@newman2004finding]]{.nord-light}, where higher $Q$ values indicate more modular networks.

![](media/Louvain.png){width=100%}
:::

::: {.column width="5%"}
:::

::: {.column width="40%"}
![Figure reproduced from [@blondel2008fast]{.nord-light}](media/Louvain_alg.png){.shadow-img width=100%}
:::
::::

::: {.notes}
It starts by assuming that every node in a network is in it's own community and calculates a modularity score $Q$ for the network. Nodes are then randomly moved into different groups and $Q$ is re-calculated. If it increased, the community assignment is retained. This process continues until the node assignments have maximized $Q$ at the level of the observed network.

Next, a simplified network is created by aggregating nodes into their assigned communities and the modularity maximization process is repeated. Communities are merged with other communities, and the mergers are retained if $Q$ increases. This process continues iteratively until $Q$ has been maximized.
:::


##

:::: {.columns}
::: {.column width="55%"}

[😲😰😰😰]{.large-text}

Some **well-known problems**:

- the resolution limit
- getting stuck in local optima
- creating disconnected communities
- can only identify assortative structure
- finds "communities" in random networks
- the illusion of greater objectivity<br>[[see @moody2023cohesion]]{.nord-footer}
- simultaneously over- and under-fit<br>[[see @peixoto2023descriptive]]{.nord-footer}
- often has a degenerate solution space<br>[[see @peixoto2023descriptive]]{.nord-footer}
- etc.

[There have been some improvements to modularity-maximization approaches [[e.g., @traag2019louvain]]{.nord-light}, but these only go so far. There are **fundamental problems** with the modularity-maximization idea, and heuristic approaches in general.]{.fragment}
:::
::: {.column width=45%}
:::
::::

::: {.notes}
...

There are well-known problems with the Louvain algorithm, including **the resolution limit**, which prevents Louvain from detecting meaningful small communities due to inappropriate merging at higher levels. Louvain can also get **stuck in local optima**, causing it to stop looking for better partitions because it "thinks" (incorrectly) that $Q$ has been maximized. And sometimes it **creates disconnected communities**!
:::



# References

